/*21.Є дві сукупності цілих додатних чисел. Одна виражає ширини тих прогалин, які дуже
бажано перекрити мостами. Інша виражає довжини тих мостів, котрі можна перевезти
на потрібне місце й там установити. Кількості чисел в цих двох сукупностях можуть
бути хоч однаковими, хоч різними. Міст можна встановити через прогалину тоді й
тільки тоді, коли довжина мосту строго більша ширини прогалини. Попереднє речення означає
також, що в цій задачі заборонено хоч «зчіплювати мости докупи» (наприклад, якщо прогалина має ширину 100, то абсолютно
необхідно використати для неї окремий міст, що має довжину 101 чи більше, а яка завгодно кількість мостів яких завгодно довжин,
менших чи рівних 100, тут не допоможе), хоч «перекривати одним мостом кілька прогалин» (що цілком природно, коли ті
прогалини завжди далеко одна від одної, а випадок, що вони можуть бути й поруч, тут не розглядається). Якумаксимальну
кількість прогалин вдасться перекрити мостами? (Так, це не зовсім природне питання, бо в такій ситуації
зазвичай виділяють більш і менш пріоритетні місця, а не міряють суто кількістю; однак, то виходить інша задача, а в цій питають
усе-таки максимальну кількість.) Наприклад, коли ширини прогалин становлять 5 200 500 150 200, а довжини мостів
10 300 250 12 15, то відповіддю буде 3, бо прогалину 500 перекривати взагалі нема чим, будь-які дві (але лише дві) з трьох
прогалин 200 150 200 вийде перекрити мостами 300 250, і прогалину 5 можна перекрити будь-яким з невикористаних мостів
10 12 15. Програма повинна вивести одне ціле додатне число (максимальна кількість прогалин, які вдасться перекрити), без
додаткових пояснень; але такі пояснення повинні бути вже написаними, а не формулюватися усно вже під час захисту.*/
using System;
class Program
{
    static void Main()
    {
        Console.Write("Введiть ширини прогалин: ");
        string input = Console.ReadLine();
        string[] parts = input.Split();
        int[] numbers = new int[parts.Length];

        Console.Write("Введiть довжини мостiв: ");
        string data = Console.ReadLine();
        string[] n = data.Split();
        int[] leng = new int[n.Length];

        if (vvod(numbers, parts) && vvod(leng, n))
        {
            sort(numbers);
            sort(leng);
            sum(numbers, leng);
        }
    }
    static bool vvod(int[] arr, string[] parts)
    {
        for (int i = 0; i < parts.Length; i++)
        {
            if (!int.TryParse(parts[i], out arr[i]) || arr[i] <= 0)
            {
                Console.WriteLine("Некоректний ввiд.");
                return false;
            }
        }
        return true;
    }
    static void sort(int[] numbers)
    {
        for (int i = 0; i < numbers.Length; i++)
        {
            for (int j = 0; j < numbers.Length - 1; j++)
            {
                if (numbers[j] > numbers[j + 1])
                {
                    int temp = numbers[j];
                    numbers[j] = numbers[j + 1];
                    numbers[j + 1] = temp;
                }
            }
        }
    }
    static void sum(int[] numbers, int[] lens)
    {
        int count = 0;
        for (int i = 0, j = 0; i < numbers.Length && j < lens.Length; j++)
        {
            if (lens[j] > numbers[i])
            {
                count++;
                i++;
            }
        }
        Console.WriteLine($"Максимальна кiлькість прогалин яку вдасться перекрити мостами: {count}");
    }
}
